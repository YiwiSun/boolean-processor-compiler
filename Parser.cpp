#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <vector>
#include <cstring>
#include <chrono>
// #define NDEBUG
#include <cassert>

#include "parser.h"

using namespace std;

/**
 * @brief Parse netlist files (.v) generated by yosys
 **/

//! Instance a new gate-level netlist parser.
Parser::Parser() {

}

//! Destructor
Parser::~Parser() {

}

void Parser::parse_v(std::string& v_path){
    ifstream inf(v_path);
    if(!inf) {
        std::cout << "File" << v_path << "Open Error!" <<endl;
        std::cout << "Exit!" <<endl;
        exit(-1);
    }

    string full_line = "";
    bool process_mode = false;      // the start signal to parse module
    bool end_of_line_found = false;
    unsigned long long lut_num = 0; // the number of total luts
    unsigned long long dff_num = 0; // the number of dffs
    unsigned input_num = 0;
    unsigned output_num = 0;
    unsigned inter_num = 0;
    unsigned input_bits = 0;
    unsigned output_bits = 0;
    unsigned inter_bits = 0;

    while(!inf.eof()) {
        std::string line;
        getline(inf, line);
        line.erase(0, line.find_first_not_of(" ")); 
        line.erase(line.find_last_not_of(" ") + 1);
        if(line == " ") {
            continue;
        }

        vector<std::string> tmp;
        std::string delims = " \t\r\n";
        tmp = Split(line, delims);
        if(tmp.size() == 0) {
            continue;
        }
        if(tmp[0] == "") {
            std::cout << "ERROR: string " << line << endl;
            exit(-1);
        }
        if(tmp[0] == "(*") {
            continue;
        }

        transform(tmp[0].begin(), tmp[0].end(), tmp[0].begin(), ::tolower);
        if(tmp[0] == "module") {
            process_mode = true;
            if(tmp[1].find("(") != string::npos) {
                top_module_name = tmp[1].substr(0, tmp[1].find("("));
            }
            else {
                top_module_name = tmp[1];
            }        
            continue;
        }
        else if(tmp[0] == "endmodule") {
            process_mode = false;
            break;
        }

        // start parsing
        if(process_mode && !end_of_line_found) {
            // combine lines
            line.erase(0, line.find_first_not_of(" "));
            line.erase(line.find_last_not_of(" ") + 1);
            std::string new_line = line;
            full_line = full_line + " " + new_line;
            if(new_line.size() > 0 && new_line[new_line.size() - 1] == ';') 
            {
                tmp = Split(full_line, " \t\r\n");
                full_line = "";
                end_of_line_found = false;
                if(tmp[0] == "input" || tmp[0] == "output" || tmp[0] == "inout" || tmp[0] == "wire" || tmp[0] == "reg") {
                    Pin cur_pin;
                    // multiple bits pin
                    if(tmp[1].find(":") != std::string::npos) 
                    {
                        assert(tmp.size() > 2);
                        cur_pin.type = tmp[0];
                        std::string tmp_name;
                        if (tmp[2][tmp[2].size() - 1] == ';')
                            tmp_name = tmp[2].substr(0, tmp[2].size() - 1);
                        else
                            tmp_name = tmp[2];    
                        cur_pin.name = tmp_name; 
                        if(pins.find(cur_pin.name) != pins.end()) 
                        {
                            assert(pins.find(cur_pin.name)->second.type == "input" || pins.find(cur_pin.name)->second.type == "output" || pins.find(cur_pin.name)->second.type == "inout");
                            continue;
                        }                
                        cur_pin.lindex = stoi(tmp[1].substr(tmp[1].find("[") + 1, tmp[1].find(":") - tmp[1].find("[") - 1));                     
                        cur_pin.rindex = stoi(tmp[1].substr(tmp[1].find(":") + 1, tmp[1].find("]") - tmp[1].find(":") - 1));                      
                        cur_pin.size = max(cur_pin.lindex, cur_pin.rindex) - min(cur_pin.lindex, cur_pin.rindex) + 1;                     
                        pins[tmp_name] = cur_pin;
                        int i = cur_pin.lindex;
                        for(int j = 0; j < cur_pin.size; j++) {
                            std::string _name = tmp_name + "[" + to_string(i) + "]";
                            // pin_bits.push_back(_name);
                            pin_bits.insert(pair<string, string>(_name, cur_pin.type));
                            if(cur_pin.lindex > cur_pin.rindex) {
                                i--;
                            }
                            else {
                                i++;
                            }
                        }
                    }
                    // single bit pin
                    else 
                    {
                        cur_pin.type = tmp[0];
                        std::string tmp_name;
                        if (tmp[1][tmp[1].size() - 1] == ';')
                            tmp_name = tmp[1].substr(0, tmp[1].size() - 1);
                        else
                            tmp_name = tmp[1];
                        cur_pin.name = tmp_name;
                        if (pins.find(cur_pin.name) != pins.end()) {                        
                            assert(pins.find(cur_pin.name)->second.type == "input" || pins.find(cur_pin.name)->second.type == "output" || pins.find(cur_pin.name)->second.type == "inout");
                            continue;
                        }
                        cur_pin.lindex = -1;  
                        cur_pin.rindex = -1;                       
                        cur_pin.size = 1;                       
                        pins[tmp_name] = cur_pin;
                        pin_bits.insert(pair<string, string>(tmp_name, cur_pin.type));
                    }
                }
                
                else if(tmp[0] == "assign") 
                {
                    auto jdg = find(tmp.begin(), tmp.end(), ">>");
                    if (jdg == tmp.end())
                    {  
                        if ((tmp[2] == "=" && pin_bits.find(tmp[1]) != pin_bits.end()) || (tmp[3] == "=" && pin_bits.find(tmp[1] + tmp[2]) != pin_bits.end()))
                        {
                            assert(tmp.size() <= 7 && tmp.size() >= 4);
                            if (tmp[2] == "=")
                            {
                                assert(tmp.size() <= 6 && tmp.size() >= 4);
                                std::string left = tmp[1];
                                std::string right;
                                if (tmp.size() == 4)
                                {
                                    assert(tmp[3][tmp[3].size() - 1] == ';');
                                    right = tmp[3].substr(0, tmp[3].size() - 1);
                                }
                                else if (tmp.size() == 5)
                                {
                                    assert(tmp[4] == ";" || tmp[4][tmp[4].size() - 1] == ';');
                                    if (tmp[4] == ";")
                                        right = tmp[3];
                                    else
                                        right = tmp[3] + tmp[4].substr(0, tmp[4].size() - 1);
                                }
                                else if (tmp.size() == 6)
                                {
                                    assert(tmp[5] == ";");
                                    right = tmp[3] + tmp[4];
                                }
                                assert(pin_bits.find(left) != pin_bits.end());
                                assert(pin_bits.find(right) != pin_bits.end() || right == "1\'b1" || right == "1\'b0" || right == "1\'bx" || right == "1\'h1" || right == "1\'h0" || right == "1\'hx");
                                if (right == "1\'b1" || right == "1\'b0" || right == "1\'bx" || right == "1\'h1" || right == "1\'h0" || right == "1\'hx")
                                {
                                    TimedValues *tvs = new TimedValues();
                                    TimedValue t_val;
                                    t_val.t = 0;
                                    t_val.value = ((right == "1\'b1" || right == "1\'h1") ? VCD_1 : VCD_0);
                                    tvs->push_back(t_val);
                                    pinbitValues[left] = tvs;
                                }
                                else
                                {
                                    assign_pairs[left] = right;
                                }
                            }
                            else
                            {
                                assert(tmp[3] == "=");
                                assert(tmp.size() <= 7 && tmp.size() >= 5);
                                std::string left = tmp[1] + tmp[2];
                                std::string right;
                                if (tmp.size() == 5)
                                {
                                    assert(tmp[4][tmp[4].size() - 1] == ';');
                                    right = tmp[4].substr(0, tmp[4].size() - 1);
                                }
                                else if (tmp.size() == 6)
                                {
                                    assert(tmp[5] == ";" || tmp[5][tmp[5].size() - 1] == ';');
                                    if (tmp[5] == ";")
                                        right = tmp[4];
                                    else
                                        right = tmp[4] + tmp[5].substr(0, tmp[5].size() - 1);
                                }
                                else if (tmp.size() == 7)
                                {
                                    assert(tmp[6] == ";");
                                    right = tmp[4] + tmp[5];
                                }
                                assert(pin_bits.find(left) != pin_bits.end());
                                assert(pin_bits.find(right) != pin_bits.end() || right == "1\'b1" || right == "1\'b0" || right == "1\'bx" || right == "1\'h1" || right == "1\'h0" || right == "1\'hx");
                                if (right == "1\'b1" || right == "1\'b0" || right == "1\'bx" || right == "1\'h1" || right == "1\'h0" || right == "1\'hx")
                                {
                                    TimedValues *tvs = new TimedValues();
                                    TimedValue t_val;
                                    t_val.t = 0;
                                    t_val.value = ((right == "1\'b1" || right == "1\'h1") ? VCD_1 : VCD_0);
                                    tvs->push_back(t_val);
                                    pinbitValues[left] = tvs;
                                }
                                else
                                {
                                    assign_pairs[left] = right;
                                }
                            }
                        }
                        else
                        {
                            string assign_sig;
                            vector<string> assign_sig_bit;
                            string assign_sig_right;
                            vector<string> assign_sig_bit_right;
                            auto eql = find(tmp.begin(), tmp.end(), "=");
                            // parsing assignment signals (left)
                            for (auto as = tmp.begin() + 1; as < eql; as++)
                            {
                                assign_sig += *as;
                            }
                            if (assign_sig.find('{') != string::npos && assign_sig.find('}') != string::npos)
                            {
                                assign_sig = assign_sig.substr(assign_sig.find("{") + 1, assign_sig.find("}") - assign_sig.find("{") - 1);
                                vector<string> mul_pin_assign_sig = Split(assign_sig, ",");
                                if (assign_sig.find(":") != std::string::npos)
                                {
                                    vector<int> mul_pin_index;
                                    vector<string> tmp_assign_sig_bit;
                                    int cur_idx = 0;
                                    for (int i = 0; i < mul_pin_assign_sig.size(); i++)
                                    {
                                        if (mul_pin_assign_sig[i].find(":") != string::npos)
                                        {
                                            mul_pin_index.push_back(i);
                                        }
                                    }
                                    for (int idx : mul_pin_index)
                                    {
                                        vector<string> mul_pin;
                                        volatile int index = 0;
                                        int count = 0;
                                        int _index = 0;
                                        while ((_index = mul_pin_assign_sig[idx].find("[", _index)) < mul_pin_assign_sig[idx].length())
                                        {
                                            count++;
                                            _index++;
                                            index = _index;
                                        }
                                        if (count == 2)
                                        {
                                            int index2 = 0;
                                            int count2 = 0;
                                            int _index2 = 0;
                                            while ((_index2 = mul_pin_assign_sig[idx].find("]", _index2)) < mul_pin_assign_sig[idx].length())
                                            {
                                                count2++;
                                                _index2++;
                                                index2 = _index2;
                                            }
                                            assert(count2 == 2);
                                            int left = stoi(mul_pin_assign_sig[idx].substr(index, mul_pin_assign_sig[idx].find(":") - (index - 1) - 1));
                                            int right = stoi(mul_pin_assign_sig[idx].substr(mul_pin_assign_sig[idx].find(":") + 1, index2 - 1 - mul_pin_assign_sig[idx].find(":") - 1));
                                            int len = max(left, right) - min(left, right) + 1;
                                            if (left > right)
                                            {
                                                for (int i = 0; i < len; i++)
                                                {
                                                    mul_pin.push_back(mul_pin_assign_sig[idx].substr(0, index - 1 + 1) + to_string(left - i) + "]");
                                                }
                                            }
                                            else
                                            {
                                                for (int i = 0; i < len; i++)
                                                {
                                                    mul_pin.push_back(mul_pin_assign_sig[idx].substr(0, index - 1 + 1) + to_string(left + i) + "]");
                                                }
                                            }
                                            for (int i = cur_idx; i < idx; i++)
                                            {
                                                tmp_assign_sig_bit.push_back(mul_pin_assign_sig[i]);
                                            }
                                            for (int i = 0; i < mul_pin.size(); i++)
                                            {
                                                tmp_assign_sig_bit.push_back(mul_pin[i]);
                                            }
                                            cur_idx = idx + 1;
                                        }
                                        else
                                        {
                                            assert(count == 1);
                                            int left = stoi(mul_pin_assign_sig[idx].substr(mul_pin_assign_sig[idx].find("[") + 1, mul_pin_assign_sig[idx].find(":") - mul_pin_assign_sig[idx].find("[") - 1));
                                            int right = stoi(mul_pin_assign_sig[idx].substr(mul_pin_assign_sig[idx].find(":") + 1, mul_pin_assign_sig[idx].find("]") - mul_pin_assign_sig[idx].find(":") - 1));
                                            int len = max(left, right) - min(left, right) + 1;
                                            if (left > right)
                                            {
                                                for (int i = 0; i < len; i++)
                                                {
                                                    mul_pin.push_back(mul_pin_assign_sig[idx].substr(0, mul_pin_assign_sig[idx].find("[") + 1) + to_string(left - i) + "]");
                                                }
                                            }
                                            else
                                            {
                                                for (int i = 0; i < len; i++)
                                                {
                                                    mul_pin.push_back(mul_pin_assign_sig[idx].substr(0, mul_pin_assign_sig[idx].find("[") + 1) + to_string(left + i) + "]");
                                                }
                                            }
                                            for (int i = cur_idx; i < idx; i++)
                                            {
                                                tmp_assign_sig_bit.push_back(mul_pin_assign_sig[i]);
                                            }

                                            for (int i = 0; i < mul_pin.size(); i++)
                                            {
                                                tmp_assign_sig_bit.push_back(mul_pin[i]);
                                            }
                                            cur_idx = idx + 1;
                                        }
                                    }
                                    if (cur_idx != mul_pin_assign_sig.size())
                                    {
                                        for (int i = cur_idx; i < mul_pin_assign_sig.size(); i++)
                                        {
                                            tmp_assign_sig_bit.push_back(mul_pin_assign_sig[i]);
                                        }
                                    }
                                    mul_pin_assign_sig = tmp_assign_sig_bit;
                                }
                                if (assign_sig.find("'") != std::string::npos)
                                {
                                    vector<int> mul_pin_index;
                                    vector<string> tmp_assign_sig_bit;
                                    int cur_idx = 0;
                                    for (int i = 0; i < mul_pin_assign_sig.size(); i++)
                                    {
                                        if (mul_pin_assign_sig[i].find("'") != string::npos)
                                        {
                                            mul_pin_index.push_back(i);
                                        }
                                    }
                                    for (int idx : mul_pin_index)
                                    {
                                        vector<string> mul_pin;
                                        string value_width = mul_pin_assign_sig[idx].substr(0, mul_pin_assign_sig[idx].find("'"));
                                        string value_value = mul_pin_assign_sig[idx].substr(mul_pin_assign_sig[idx].find("'") + 2, mul_pin_assign_sig[idx].size() - mul_pin_assign_sig[idx].find("'") - 2);
                                        string value_value_bin;
                                        if (value_value.size() == stoi(value_width.c_str()))
                                            value_value_bin = value_value;
                                        else
                                        {
                                            string tmp_value_value_bin = HextoBinary_x(value_value);
                                            if (tmp_value_value_bin.size() >= stoi(value_width.c_str()))
                                                value_value_bin = tmp_value_value_bin.substr(tmp_value_value_bin.length() - stoi(value_width.c_str()));
                                            else
                                                value_value_bin = string(stoi(value_width.c_str()) - tmp_value_value_bin.size(), 0) + tmp_value_value_bin;                                          
                                        }
                                        for (auto iter = value_value_bin.begin(); iter != value_value_bin.end(); iter++)
                                        {
                                            string s(1, *iter);
                                            mul_pin.push_back(s);
                                        }
                                        for (int i = cur_idx; i < idx; i++)
                                        {
                                            tmp_assign_sig_bit.push_back(mul_pin_assign_sig[i]);
                                        }
                                        for (int i = 0; i < mul_pin.size(); i++)
                                        {
                                            tmp_assign_sig_bit.push_back(mul_pin[i]);
                                        }
                                        cur_idx = idx + 1;
                                    }
                                    if (cur_idx != mul_pin_assign_sig.size())
                                    {
                                        for (int i = cur_idx; i < mul_pin_assign_sig.size(); i++)
                                        {
                                            tmp_assign_sig_bit.push_back(mul_pin_assign_sig[i]);
                                        }
                                    }
                                    mul_pin_assign_sig = tmp_assign_sig_bit;
                                }
                                vector<int> mul_pin_index;
                                vector<string> tmp_assign_sig_bit;
                                int cur_idx = 0;
                                for (int i = 0; i < mul_pin_assign_sig.size(); i++)
                                {
                                    auto find_pinbit = pin_bits.find(mul_pin_assign_sig[i]);
                                    if (find_pinbit == pin_bits.end() && mul_pin_assign_sig[i] != "0" && mul_pin_assign_sig[i] != "1" && mul_pin_assign_sig[i] != "x")
                                    {
                                        mul_pin_index.push_back(i);
                                    }
                                }
                                for (int idx : mul_pin_index)
                                {
                                    vector<string> mul_pin;
                                    auto find_pins = pins.find(mul_pin_assign_sig[idx]);
                                    assert(find_pins != pins.end());
                                    int lin = pins[mul_pin_assign_sig[idx]].lindex;
                                    for (int j = 0; j < pins[mul_pin_assign_sig[idx]].size; j++)
                                    {
                                        std::string _name = mul_pin_assign_sig[idx] + "[" + to_string(lin) + "]";
                                        mul_pin.push_back(_name);
                                        if (pins[mul_pin_assign_sig[idx]].lindex > pins[mul_pin_assign_sig[idx]].rindex)
                                        {
                                            lin--;
                                        }
                                        else
                                        {
                                            lin++;
                                        }
                                    }
                                    for (int i = cur_idx; i < idx; i++)
                                    {
                                        tmp_assign_sig_bit.push_back(mul_pin_assign_sig[i]);
                                    }
                                    for (int i = 0; i < mul_pin.size(); i++)
                                    {
                                        tmp_assign_sig_bit.push_back(mul_pin[i]);
                                    }
                                    cur_idx = idx + 1;
                                }
                                if (cur_idx != mul_pin_assign_sig.size())
                                {
                                    for (int i = cur_idx; i < mul_pin_assign_sig.size(); i++)
                                    {
                                        tmp_assign_sig_bit.push_back(mul_pin_assign_sig[i]);
                                    }
                                }
                                mul_pin_assign_sig = tmp_assign_sig_bit;

                                for (auto i = mul_pin_assign_sig.begin(); i != mul_pin_assign_sig.end(); i++)
                                {
                                    auto find_pinbit = pin_bits.find(*i);
                                    assert(find_pinbit != pin_bits.end() || *i == "0" || *i == "1" || *i == "x");
                                }
                                assign_sig_bit = mul_pin_assign_sig;
                            }
                            else if (assign_sig.find(':') == string::npos || assign_sig.find('[') == string::npos || assign_sig.find(']') == string::npos)
                            {
                                assert(pins.find(assign_sig) != pins.end());
                                int lin = pins[assign_sig].lindex;
                                for (int j = 0; j < pins[assign_sig].size; j++)
                                {
                                    std::string _name = assign_sig + "[" + to_string(lin) + "]";
                                    assign_sig_bit.push_back(_name);
                                    if (pins[assign_sig].lindex > pins[assign_sig].rindex)
                                    {
                                        lin--;
                                    }
                                    else
                                    {
                                        lin++;
                                    }
                                }
                            }
                            else
                            {
                                assert(assign_sig.find('[') != string::npos && assign_sig.find(':') != string::npos && assign_sig.find(']') != string::npos);
                                volatile int index = 0;
                                int count = 0;
                                int _index = 0;
                                while ((_index = assign_sig.find("[", _index)) < assign_sig.length())
                                {
                                    count++;
                                    _index++;
                                    index = _index;
                                }
                                if (count == 2)
                                {
                                    int index2 = 0;
                                    int count2 = 0;
                                    int _index2 = 0;
                                    while ((_index2 = assign_sig.find("]", _index2)) < assign_sig.length())
                                    {
                                        count2++;
                                        _index2++;
                                        index2 = _index2;
                                    }
                                    assert(count2 == 2);
                                    int left = stoi(assign_sig.substr(index, assign_sig.find(":") - (index - 1) - 1));
                                    int right = stoi(assign_sig.substr(assign_sig.find(":") + 1, index2 - 1 - assign_sig.find(":") - 1));
                                    int len = max(left, right) - min(left, right) + 1;
                                    if (left > right)
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            assign_sig_bit.push_back(assign_sig.substr(0, index - 1 + 1) + to_string(left - i) + "]");
                                        }
                                    }
                                    else
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            assign_sig_bit.push_back(assign_sig.substr(0, index - 1 + 1) + to_string(left + i) + "]");
                                        }
                                    }
                                    for (int i = 0; i < assign_sig_bit.size(); i++)
                                    {
                                        auto iter = pin_bits.find(assign_sig_bit[i]);
                                        assert(iter != pin_bits.end());
                                    }
                                }
                                else
                                {
                                    assert(count == 1);
                                    int left = stoi(assign_sig.substr(assign_sig.find("[") + 1, assign_sig.find(":") - assign_sig.find("[") - 1));
                                    int right = stoi(assign_sig.substr(assign_sig.find(":") + 1, assign_sig.find("]") - assign_sig.find(":") - 1));
                                    int len = max(left, right) - min(left, right) + 1;
                                    if (left > right)
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            assign_sig_bit.push_back(assign_sig.substr(0, assign_sig.find("[") + 1) + to_string(left - i) + "]");
                                        }
                                    }
                                    else
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            assign_sig_bit.push_back(assign_sig.substr(0, assign_sig.find("[") + 1) + to_string(left + i) + "]");
                                        }
                                    }
                                    for (int i = 0; i < assign_sig_bit.size(); i++)
                                    {
                                        auto iter = pin_bits.find(assign_sig_bit[i]);
                                        assert(iter != pin_bits.end());
                                    }
                                }
                            }

                            // parsing assignment signals (right)
                            for (auto as = eql + 1; as != tmp.end(); as++)
                            {
                                assign_sig_right += *as;
                            }
                            assert(assign_sig_right[assign_sig_right.size() - 1] == ';');
                            assign_sig_right = assign_sig_right.substr(0, assign_sig_right.size() - 1);
                            if (assign_sig_right.find('{') != string::npos && assign_sig_right.find('}') != string::npos)
                            {
                                assign_sig_right = assign_sig_right.substr(assign_sig_right.find("{") + 1, assign_sig_right.find("}") - assign_sig_right.find("{") - 1);
                                vector<string> mul_pin_assign_sig_right = Split(assign_sig_right, ",");
                                if (assign_sig_right.find(":") != std::string::npos)
                                {
                                    vector<int> mul_pin_index;
                                    vector<string> tmp_assign_sig_bit_right;
                                    int cur_idx = 0;
                                    for (int i = 0; i < mul_pin_assign_sig_right.size(); i++)
                                    {
                                        if (mul_pin_assign_sig_right[i].find(":") != string::npos)
                                        {
                                            mul_pin_index.push_back(i);
                                        }
                                    }
                                    for (int idx : mul_pin_index)
                                    {
                                        vector<string> mul_pin;
                                        volatile int index = 0;
                                        int count = 0;
                                        int _index = 0;
                                        while ((_index = mul_pin_assign_sig_right[idx].find("[", _index)) < mul_pin_assign_sig_right[idx].length())
                                        {
                                            count++;
                                            _index++;
                                            index = _index;
                                        }
                                        if (count == 2)
                                        {
                                            int index2 = 0;
                                            int count2 = 0;
                                            int _index2 = 0;
                                            while ((_index2 = mul_pin_assign_sig_right[idx].find("]", _index2)) < mul_pin_assign_sig_right[idx].length())
                                            {
                                                count2++;
                                                _index2++;
                                                index2 = _index2;
                                            }
                                            assert(count2 == 2);
                                            int left = stoi(mul_pin_assign_sig_right[idx].substr(index, mul_pin_assign_sig_right[idx].find(":") - (index - 1) - 1));
                                            int right = stoi(mul_pin_assign_sig_right[idx].substr(mul_pin_assign_sig_right[idx].find(":") + 1, index2 - 1 - mul_pin_assign_sig_right[idx].find(":") - 1));
                                            int len = max(left, right) - min(left, right) + 1;
                                            if (left > right)
                                            {
                                                for (int i = 0; i < len; i++)
                                                {
                                                    mul_pin.push_back(mul_pin_assign_sig_right[idx].substr(0, index - 1 + 1) + to_string(left - i) + "]");
                                                }
                                            }
                                            else
                                            {
                                                for (int i = 0; i < len; i++)
                                                {
                                                    mul_pin.push_back(mul_pin_assign_sig_right[idx].substr(0, index - 1 + 1) + to_string(left + i) + "]");
                                                }
                                            }
                                            for (int i = cur_idx; i < idx; i++)
                                            {
                                                tmp_assign_sig_bit_right.push_back(mul_pin_assign_sig_right[i]);
                                            }
                                            for (int i = 0; i < mul_pin.size(); i++)
                                            {
                                                tmp_assign_sig_bit_right.push_back(mul_pin[i]);
                                            }
                                            cur_idx = idx + 1;
                                        }
                                        else
                                        {
                                            assert(count == 1);
                                            int left = stoi(mul_pin_assign_sig_right[idx].substr(mul_pin_assign_sig_right[idx].find("[") + 1, mul_pin_assign_sig_right[idx].find(":") - mul_pin_assign_sig_right[idx].find("[") - 1));
                                            int right = stoi(mul_pin_assign_sig_right[idx].substr(mul_pin_assign_sig_right[idx].find(":") + 1, mul_pin_assign_sig_right[idx].find("]") - mul_pin_assign_sig_right[idx].find(":") - 1));
                                            int len = max(left, right) - min(left, right) + 1;
                                            if (left > right)
                                            {
                                                for (int i = 0; i < len; i++)
                                                {
                                                    mul_pin.push_back(mul_pin_assign_sig_right[idx].substr(0, mul_pin_assign_sig_right[idx].find("[") + 1) + to_string(left - i) + "]");
                                                }
                                            }
                                            else
                                            {
                                                for (int i = 0; i < len; i++)
                                                {
                                                    mul_pin.push_back(mul_pin_assign_sig_right[idx].substr(0, mul_pin_assign_sig_right[idx].find("[") + 1) + to_string(left + i) + "]");
                                                }
                                            }
                                            for (int i = cur_idx; i < idx; i++)
                                            {
                                                tmp_assign_sig_bit_right.push_back(mul_pin_assign_sig_right[i]);
                                            }

                                            for (int i = 0; i < mul_pin.size(); i++)
                                            {
                                                tmp_assign_sig_bit_right.push_back(mul_pin[i]);
                                            }
                                            cur_idx = idx + 1;
                                        }
                                    }
                                    if (cur_idx != mul_pin_assign_sig_right.size())
                                    {
                                        for (int i = cur_idx; i < mul_pin_assign_sig_right.size(); i++)
                                        {
                                            tmp_assign_sig_bit_right.push_back(mul_pin_assign_sig_right[i]);
                                        }
                                    }
                                    mul_pin_assign_sig_right = tmp_assign_sig_bit_right;
                                }
                                if (assign_sig_right.find("'") != std::string::npos)
                                {
                                    vector<int> mul_pin_index;
                                    vector<string> tmp_assign_sig_bit_right;
                                    int cur_idx = 0;
                                    for (int i = 0; i < mul_pin_assign_sig_right.size(); i++)
                                    {
                                        if (mul_pin_assign_sig_right[i].find("'") != string::npos)
                                        {
                                            mul_pin_index.push_back(i);
                                        }
                                    }
                                    for (int idx : mul_pin_index)
                                    {
                                        vector<string> mul_pin;
                                        string value_width = mul_pin_assign_sig_right[idx].substr(0, mul_pin_assign_sig_right[idx].find("'"));
                                        string value_value = mul_pin_assign_sig_right[idx].substr(mul_pin_assign_sig_right[idx].find("'") + 2, mul_pin_assign_sig_right[idx].size() - mul_pin_assign_sig_right[idx].find("'") - 2);
                                        string value_value_bin;
                                        if (value_value.size() == stoi(value_width.c_str()))
                                            value_value_bin = value_value;
                                        else
                                        {
                                            string tmp_value_value_bin = HextoBinary_x(value_value);
                                            if (tmp_value_value_bin.size() >= stoi(value_width.c_str()))
                                                value_value_bin = tmp_value_value_bin.substr(tmp_value_value_bin.length() - stoi(value_width.c_str()));
                                            else
                                                value_value_bin = string(stoi(value_width.c_str()) - tmp_value_value_bin.size(), 0) + tmp_value_value_bin;                       
                                        }
                                        for (auto iter = value_value_bin.begin(); iter != value_value_bin.end(); iter++)
                                        {
                                            string s(1, *iter);
                                            mul_pin.push_back(s);
                                        }
                                        for (int i = cur_idx; i < idx; i++)
                                        {
                                            tmp_assign_sig_bit_right.push_back(mul_pin_assign_sig_right[i]);
                                        }
                                        for (int i = 0; i < mul_pin.size(); i++)
                                        {
                                            tmp_assign_sig_bit_right.push_back(mul_pin[i]);
                                        }
                                        cur_idx = idx + 1;
                                    }
                                    if (cur_idx != mul_pin_assign_sig_right.size())
                                    {
                                        for (int i = cur_idx; i < mul_pin_assign_sig_right.size(); i++)
                                        {
                                            tmp_assign_sig_bit_right.push_back(mul_pin_assign_sig_right[i]);
                                        }
                                    }
                                    mul_pin_assign_sig_right = tmp_assign_sig_bit_right;
                                }
                                vector<int> mul_pin_index;
                                vector<string> tmp_assign_sig_bit_right;
                                int cur_idx = 0;
                                for (int i = 0; i < mul_pin_assign_sig_right.size(); i++)
                                {
                                    auto find_pinbit = pin_bits.find(mul_pin_assign_sig_right[i]);
                                    if (find_pinbit == pin_bits.end() && mul_pin_assign_sig_right[i] != "0" && mul_pin_assign_sig_right[i] != "1" && mul_pin_assign_sig_right[i] != "x")
                                    {
                                        mul_pin_index.push_back(i);
                                    }
                                }
                                for (int idx : mul_pin_index)
                                {
                                    vector<string> mul_pin;
                                    auto find_pins = pins.find(mul_pin_assign_sig_right[idx]);
                                    assert(find_pins != pins.end());
                                    int lin = pins[mul_pin_assign_sig_right[idx]].lindex;
                                    for (int j = 0; j < pins[mul_pin_assign_sig_right[idx]].size; j++)
                                    {
                                        std::string _name = mul_pin_assign_sig_right[idx] + "[" + to_string(lin) + "]";
                                        mul_pin.push_back(_name);
                                        if (pins[mul_pin_assign_sig_right[idx]].lindex > pins[mul_pin_assign_sig_right[idx]].rindex)
                                        {
                                            lin--;
                                        }
                                        else
                                        {
                                            lin++;
                                        }
                                    }
                                    for (int i = cur_idx; i < idx; i++)
                                    {
                                        tmp_assign_sig_bit_right.push_back(mul_pin_assign_sig_right[i]);
                                    }
                                    for (int i = 0; i < mul_pin.size(); i++)
                                    {
                                        tmp_assign_sig_bit_right.push_back(mul_pin[i]);
                                    }
                                    cur_idx = idx + 1;
                                }
                                if (cur_idx != mul_pin_assign_sig_right.size())
                                {
                                    for (int i = cur_idx; i < mul_pin_assign_sig_right.size(); i++)
                                    {
                                        tmp_assign_sig_bit_right.push_back(mul_pin_assign_sig_right[i]);
                                    }
                                }
                                mul_pin_assign_sig_right = tmp_assign_sig_bit_right;

                                for (auto i = mul_pin_assign_sig_right.begin(); i != mul_pin_assign_sig_right.end(); i++)
                                {
                                    auto find_pinbit = pin_bits.find(*i);
                                    assert(find_pinbit != pin_bits.end() || *i == "0" || *i == "1" || *i == "x");
                                }
                                assign_sig_bit_right = mul_pin_assign_sig_right;
                            }
                            else if (assign_sig_right.find("'") != string::npos)
                            {
                                int value_width = stoi(assign_sig_right.substr(0, assign_sig_right.find("'")).c_str());
                                string value_value = assign_sig_right.substr(assign_sig_right.find("'") + 2, assign_sig_right.size() - assign_sig_right.find("'") - 2);
                                string value_value_bin;
                                if (value_value.size() == value_width)
                                    value_value_bin = value_value;
                                else
                                {
                                    string tmp_value_value_bin = HextoBinary_x(value_value);
                                    if (tmp_value_value_bin.size() >= value_width)
                                        value_value_bin = tmp_value_value_bin.substr(tmp_value_value_bin.length() - value_width);
                                    else
                                        value_value_bin = string(value_width - tmp_value_value_bin.size(), 0) + tmp_value_value_bin;
                                }                                
                                for (auto iter = value_value_bin.begin(); iter != value_value_bin.end(); iter++)
                                {
                                    string s(1, *iter);
                                    assign_sig_bit_right.push_back(s);
                                }
                            }
                            else if (assign_sig_right.find(':') == string::npos || assign_sig_right.find('[') == string::npos || assign_sig_right.find(']') == string::npos)
                            {
                                assert(pins.find(assign_sig_right) != pins.end());
                                int lin = pins[assign_sig_right].lindex;
                                for (int j = 0; j < pins[assign_sig_right].size; j++)
                                {
                                    std::string _name = assign_sig_right + "[" + to_string(lin) + "]";
                                    assign_sig_bit_right.push_back(_name);
                                    if (pins[assign_sig_right].lindex > pins[assign_sig_right].rindex)
                                    {
                                        lin--;
                                    }
                                    else
                                    {
                                        lin++;
                                    }
                                }
                            }
                            else
                            {
                                assert(assign_sig_right.find('[') != string::npos && assign_sig_right.find(':') != string::npos && assign_sig_right.find(']') != string::npos);
                                volatile int index = 0;
                                int count = 0;
                                int _index = 0;
                                while ((_index = assign_sig_right.find("[", _index)) < assign_sig_right.length())
                                {
                                    count++;
                                    _index++;
                                    index = _index;
                                }
                                if (count == 2)
                                {
                                    int index2 = 0;
                                    int count2 = 0;
                                    int _index2 = 0;
                                    while ((_index2 = assign_sig_right.find("]", _index2)) < assign_sig_right.length())
                                    {
                                        count2++;
                                        _index2++;
                                        index2 = _index2;
                                    }
                                    assert(count2 == 2);
                                    int left = stoi(assign_sig_right.substr(index, assign_sig_right.find(":") - (index - 1) - 1));
                                    int right = stoi(assign_sig_right.substr(assign_sig_right.find(":") + 1, index2 - 1 - assign_sig_right.find(":") - 1));
                                    int len = max(left, right) - min(left, right) + 1;
                                    if (left > right)
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            assign_sig_bit_right.push_back(assign_sig_right.substr(0, index - 1 + 1) + to_string(left - i) + "]");
                                        }
                                    }
                                    else
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            assign_sig_bit_right.push_back(assign_sig_right.substr(0, index - 1 + 1) + to_string(left + i) + "]");
                                        }
                                    }
                                    for (int i = 0; i < assign_sig_bit_right.size(); i++)
                                    {
                                        auto iter = pin_bits.find(assign_sig_bit_right[i]);
                                        assert(iter != pin_bits.end());
                                    }
                                }
                                else
                                {
                                    assert(count == 1);
                                    int left = stoi(assign_sig_right.substr(assign_sig_right.find("[") + 1, assign_sig_right.find(":") - assign_sig_right.find("[") - 1));
                                    int right = stoi(assign_sig_right.substr(assign_sig_right.find(":") + 1, assign_sig_right.find("]") - assign_sig_right.find(":") - 1));
                                    int len = max(left, right) - min(left, right) + 1;
                                    if (left > right)
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            assign_sig_bit_right.push_back(assign_sig_right.substr(0, assign_sig_right.find("[") + 1) + to_string(left - i) + "]");
                                        }
                                    }
                                    else
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            assign_sig_bit_right.push_back(assign_sig_right.substr(0, assign_sig_right.find("[") + 1) + to_string(left + i) + "]");
                                        }
                                    }
                                    for (int i = 0; i < assign_sig_bit_right.size(); i++)
                                    {
                                        auto iter = pin_bits.find(assign_sig_bit_right[i]);
                                        assert(iter != pin_bits.end());
                                    }
                                }
                            }
                            
                            assert(assign_sig_bit.size() == assign_sig_bit_right.size());
                            for (int range = 0; range < assign_sig_bit.size(); range++)
                            {
                                if (assign_sig_bit_right[range] == "1" || assign_sig_bit_right[range] == "0" || assign_sig_bit_right[range] == "x")
                                {
                                    TimedValues *tvs = new TimedValues();
                                    TimedValue t_val;
                                    t_val.t = 0;
                                    t_val.value = (assign_sig_bit_right[range] == "1" ? VCD_1 : VCD_0);
                                    tvs->push_back(t_val);
                                    pinbitValues[assign_sig_bit[range]] = tvs;
                                }
                                else
                                {
                                    assign_pairs[assign_sig_bit[range]] = assign_sig_bit_right[range];
                                }
                            }
                        }                       
                    }
                    // lut parsing
                    else 
                    {
                        assert(tmp[2] == "=" || tmp[3] == "=");
                        assert(tmp[4] == ">>" || tmp[5] == ">>");
                        assert(tmp[tmp.size() - 1][tmp[tmp.size() - 1].size() - 1] == ';');

                        LutType cur_lut;
                        cur_lut.num = lut_num; 
                        lut_num += 1;
                        if (tmp[2] == "=")
                        {
                            cur_lut.out_ports = tmp[1];
                            string tmp_lut_res = tmp[3].substr(tmp[3].find("h") + 1, tmp[3].size() - tmp[3].find("h") - 1);
                            cur_lut.lut_res = tmp_lut_res;                           
                        }                           
                        else
                        {
                            assert(tmp[3] == "=");
                            cur_lut.out_ports = tmp[1] + tmp[2];
                            string tmp_lut_res = tmp[4].substr(tmp[4].find("h") + 1, tmp[4].size() - tmp[4].find("h") - 1);
                            cur_lut.lut_res = tmp_lut_res;
                        }
                        map<string, string>::iterator i = pin_bits.find(cur_lut.out_ports);
                        assert(i != pin_bits.end());

                        string tmp_line = "";
                        for(unsigned i = 1; i < tmp.size(); ++i) {
                            tmp_line += tmp[i];
                        }
                        if ((tmp_line.find("{") == string::npos) && (tmp_line.find("}") == string::npos))
                        {
                            string in_ports_vec = tmp_line.substr(tmp_line.find(">") + 2, tmp_line.find(";") - tmp_line.find(">") - 2);
                            // no combined pins
                            if (in_ports_vec.find(":") == string::npos || in_ports_vec.find("[") == string::npos || in_ports_vec.find("]") == string::npos)
                            {
                                if (pin_bits.find(in_ports_vec) != pin_bits.end())
                                    cur_lut.in_ports.push_back(in_ports_vec);
                                else
                                {
                                    assert(pins.find(in_ports_vec) != pins.end());
                                    int lin = pins[in_ports_vec].lindex;
                                    for (int j = 0; j < pins[in_ports_vec].size; j++)
                                    {
                                        std::string _name = in_ports_vec + "[" + to_string(lin) + "]";
                                        cur_lut.in_ports.push_back(_name);
                                        if (pins[in_ports_vec].lindex > pins[in_ports_vec].rindex)
                                        {
                                            lin--;
                                        }
                                        else
                                        {
                                            lin++;
                                        }
                                    }
                                }
                            }                      
                            // multiple bits pin
                            else
                            {
                                assert((in_ports_vec.find(":") != string::npos && in_ports_vec.find("[") != string::npos && in_ports_vec.find("]") != string::npos));
                                vector<string> mul_pin;
                                volatile int index = 0;
                                int count = 0;
                                int _index = 0;
                                while ((_index = in_ports_vec.find("[", _index)) < in_ports_vec.length())
                                {
                                    count++;
                                    _index++;
                                    index = _index;
                                }
                                if (count == 2)
                                {
                                    int index2 = 0;
                                    int count2 = 0;
                                    int _index2 = 0;
                                    while ((_index2 = in_ports_vec.find("]", _index2)) < in_ports_vec.length())
                                    {
                                        count2++;
                                        _index2++;
                                        index2 = _index2;
                                    }
                                    assert(count2 == 2);
                                    int left = stoi(in_ports_vec.substr(index, in_ports_vec.find(":") - (index - 1) - 1));
                                    int right = stoi(in_ports_vec.substr(in_ports_vec.find(":") + 1, index2 - 1 - in_ports_vec.find(":") - 1));
                                    int len = max(left, right) - min(left, right) + 1;
                                    if (left > right)
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            mul_pin.push_back(in_ports_vec.substr(0, index - 1 + 1) + to_string(left - i) + "]");
                                        }
                                    }
                                    else
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            mul_pin.push_back(in_ports_vec.substr(0, index - 1 + 1) + to_string(left + i) + "]");
                                        }
                                    }
                                    cur_lut.in_ports = mul_pin;
                                    for (int i = 0; i < cur_lut.in_ports.size(); i++)
                                    {
                                        map<string, string>::iterator iter = pin_bits.find(cur_lut.in_ports[i]);
                                        assert(iter != pin_bits.end());
                                    }
                                }
                                else
                                {
                                    assert(count == 1);
                                    int left = stoi(in_ports_vec.substr(in_ports_vec.find("[") + 1, in_ports_vec.find(":") - in_ports_vec.find("[") - 1));
                                    int right = stoi(in_ports_vec.substr(in_ports_vec.find(":") + 1, in_ports_vec.find("]") - in_ports_vec.find(":") - 1));
                                    int len = max(left, right) - min(left, right) + 1;
                                    if (left > right)
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            mul_pin.push_back(in_ports_vec.substr(0, in_ports_vec.find("[") + 1) + to_string(left - i) + "]");
                                        }
                                    }
                                    else
                                    {
                                        for (int i = 0; i < len; i++)
                                        {
                                            mul_pin.push_back(in_ports_vec.substr(0, in_ports_vec.find("[") + 1) + to_string(left + i) + "]");
                                        }
                                    }
                                    cur_lut.in_ports = mul_pin;
                                    for (int i = 0; i < cur_lut.in_ports.size(); i++)
                                    {
                                        map<string, string>::iterator iter = pin_bits.find(cur_lut.in_ports[i]);
                                        assert(iter != pin_bits.end());
                                    }
                                }
                            }                                                     
                        }
                        else
                        {
                            string in_ports_vec = tmp_line.substr(tmp_line.find("{") + 1, tmp_line.find("}") - tmp_line.find("{") - 1);
                            // no combined pins
                            if (in_ports_vec.find(":") == std::string::npos)
                            {
                                vector<string> tmp_in_ports = Split(in_ports_vec, ",");
                                cur_lut.in_ports = tmp_in_ports;
                                for (int i = 0; i < cur_lut.in_ports.size(); i++)
                                {
                                    map<string, string>::iterator iter = pin_bits.find(cur_lut.in_ports[i]);
                                    assert(iter != pin_bits.end());
                                }
                            }
                            // multiple bits pin
                            else
                            {
                                vector<string> mul_pin_in_ports = Split(in_ports_vec, ",");
                                vector<int> mul_pin_index;
                                vector<string> tmp_in_ports;
                                string in_ports = "";
                                int cur_idx = 0;
                                for (int i = 0; i < mul_pin_in_ports.size(); i++)
                                {
                                    if (mul_pin_in_ports[i].find(":") != string::npos)
                                    {
                                        mul_pin_index.push_back(i);
                                    }
                                }
                                for (int idx : mul_pin_index)
                                {
                                    vector<string> mul_pin;
                                    volatile int index = 0;
                                    int count = 0;
                                    int _index = 0;
                                    while ((_index = mul_pin_in_ports[idx].find("[", _index)) < mul_pin_in_ports[idx].length())
                                    {
                                        count++;
                                        _index++;
                                        index = _index;
                                    }
                                    if (count == 2)
                                    {
                                        int index2 = 0;
                                        int count2 = 0;
                                        int _index2 = 0;
                                        while ((_index2 = mul_pin_in_ports[idx].find("]", _index2)) < mul_pin_in_ports[idx].length())
                                        {
                                            count2++;
                                            _index2++;
                                            index2 = _index2;
                                        }
                                        assert(count2 == 2);
                                        int left = stoi(mul_pin_in_ports[idx].substr(index, mul_pin_in_ports[idx].find(":") - (index - 1) - 1));
                                        int right = stoi(mul_pin_in_ports[idx].substr(mul_pin_in_ports[idx].find(":") + 1, index2 - 1 - mul_pin_in_ports[idx].find(":") - 1));
                                        int len = max(left, right) - min(left, right) + 1;
                                        // assert(len <= 4);
                                        if (left > right)
                                        {
                                            for (int i = 0; i < len; i++)
                                            {
                                                mul_pin.push_back(mul_pin_in_ports[idx].substr(0, index - 1 + 1) + to_string(left - i) + "]");
                                            }
                                        }
                                        else
                                        {
                                            for (int i = 0; i < len; i++)
                                            {
                                                mul_pin.push_back(mul_pin_in_ports[idx].substr(0, index - 1 + 1) + to_string(left + i) + "]");
                                            }
                                        }
                                        for (int i = cur_idx; i < idx; i++)
                                        {
                                            tmp_in_ports.push_back(mul_pin_in_ports[i]);
                                        }
                                        for (int i = 0; i < mul_pin.size(); i++)
                                        {
                                            tmp_in_ports.push_back(mul_pin[i]);
                                        }
                                        cur_idx = idx + 1;
                                    }
                                    else
                                    {
                                        assert(count == 1);
                                        int left = stoi(mul_pin_in_ports[idx].substr(mul_pin_in_ports[idx].find("[") + 1, mul_pin_in_ports[idx].find(":") - mul_pin_in_ports[idx].find("[") - 1));
                                        int right = stoi(mul_pin_in_ports[idx].substr(mul_pin_in_ports[idx].find(":") + 1, mul_pin_in_ports[idx].find("]") - mul_pin_in_ports[idx].find(":") - 1));
                                        int len = max(left, right) - min(left, right) + 1;
                                        if (left > right)
                                        {
                                            for (int i = 0; i < len; i++)
                                            {
                                                mul_pin.push_back(mul_pin_in_ports[idx].substr(0, mul_pin_in_ports[idx].find("[") + 1) + to_string(left - i) + "]");
                                            }
                                        }
                                        else
                                        {
                                            for (int i = 0; i < len; i++)
                                            {
                                                mul_pin.push_back(mul_pin_in_ports[idx].substr(0, mul_pin_in_ports[idx].find("[") + 1) + to_string(left + i) + "]");
                                            }
                                        }
                                        for (int i = cur_idx; i < idx; i++)
                                        {
                                            tmp_in_ports.push_back(mul_pin_in_ports[i]);
                                        }
                                        for (int i = 0; i < mul_pin.size(); i++)
                                        {
                                            tmp_in_ports.push_back(mul_pin[i]);
                                        }
                                        cur_idx = idx + 1;
                                    }                                   
                                }
                                if (cur_idx != mul_pin_in_ports.size())
                                {
                                    for (int i = cur_idx; i < mul_pin_in_ports.size(); i++)
                                    {
                                        tmp_in_ports.push_back(mul_pin_in_ports[i]);
                                    }
                                }
                                cur_lut.in_ports = tmp_in_ports;
                                for (int i = 0; i < cur_lut.in_ports.size(); i++)
                                {
                                    map<string, string>::iterator iter = pin_bits.find(cur_lut.in_ports[i]);
                                    assert(iter != pin_bits.end());
                                }
                            }
                        }

                        luts[cur_lut.num] = cur_lut;
                        net_from_id[cur_lut.out_ports] = cur_lut.num;
                        for (int i = 0; i < cur_lut.in_ports.size(); i++)
                        {
                            net_for_id[cur_lut.in_ports[i]].push_back(cur_lut.num);
                        }
                    }
                }

                else if (tmp[0] == "always")
                {
                    DffType cur_dff;
                    cur_dff.num = dff_num;
                    dff_num += 1;
                    // cur_lut.isDff = 1;
                    vector<int> mark;
                    vector<string> sens;
                    vector<string> edge;
                    vector<vector<string>> cond;     // assignment signal, condition signal, condition
                    for (vector<string>::iterator i = tmp.begin(); i != tmp.end(); i++)
                    {
                        if (i->find(")") != string::npos)
                        {
                            mark.push_back(distance(tmp.begin(), i));
                        }
                    }
                    if (mark.size() == 1)
                        cur_dff.type = 0;
                    else if (mark.size() == 2)
                        cur_dff.type = 1;
                    // parsing sensitive signals
                    for (vector<string>::iterator i = tmp.begin() + 1; i <= tmp.begin() + mark[0]; i++)
                    {
                        if (i == tmp.begin() + 1)
                        {
                            edge.push_back(i->substr(i->find("(") + 1, i->size() - i->find("(") - 1));
                        }
                        else
                        {
                            if (distance(tmp.begin(), i) % 2)
                            {
                                edge.push_back(*i);
                            }
                            else
                            {
                                sens.push_back(i->substr(0, i->size() - 1));
                            }
                        }
                    }
                    assert(sens.size() == edge.size());
                    for (int i = 0; i < sens.size(); i++)
                    {
                        cur_dff.sens_edge.push_back(make_pair(sens[i], edge[i]));
                    }
                    // parsing assignsig_condsig <assignment signal, <condition signal, condition>>
                    if (mark.size() == 2 && *(tmp.begin() + mark[0] + 1) == "if")
                    {
                        pair<string, int> cond;
                        if ((tmp.begin() + mark[0] + 2)->find("!") == string::npos)
                            cond = make_pair((tmp.begin() + mark[0] + 2)->substr((tmp.begin() + mark[0] + 2)->find("(") + 1, (tmp.begin() + mark[0] + 2)->find(")") - (tmp.begin() + mark[0] + 2)->find("(") - 1), 1);
                        else
                            cond = make_pair((tmp.begin() + mark[0] + 2)->substr((tmp.begin() + mark[0] + 2)->find("!") + 1, (tmp.begin() + mark[0] + 2)->find(")") - (tmp.begin() + mark[0] + 2)->find("!") - 1), 0);               
                        if (*(tmp.begin() + mark[0] + 4) == "<=")
                            cur_dff.dff_out = *(tmp.begin() + mark[0] + 3);
                        else if (*(tmp.begin() + mark[0] + 5) == "<=")
                            cur_dff.dff_out = *(tmp.begin() + mark[0] + 3) + *(tmp.begin() + mark[0] + 4);
                        auto it = find(tmp.begin(), tmp.end(), "<=");
                        if ((tmp.begin() + distance(tmp.begin(), it) + 1)->find(";") != string::npos)
                        {
                            if ((tmp.begin() + distance(tmp.begin(), it) + 1)->find("'") == string::npos)
                            {
                                string assignsig = (tmp.begin() + distance(tmp.begin(), it) + 1)->substr(0, (tmp.begin() + distance(tmp.begin(), it) + 1)->size() - 1);
                                cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                            }
                            else
                            {
                                string assignsig = (tmp.begin() + distance(tmp.begin(), it) + 1)->substr((tmp.begin() + distance(tmp.begin(), it) + 1)->find("'") + 2, 1);
                                cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                            }
                        }
                        else if (((tmp.begin() + distance(tmp.begin(), it) + 1)->find(";") != string::npos) && ((tmp.begin() + distance(tmp.begin(), it) + 2)->find(";") == string::npos))
                        {
                            if ((tmp.begin() + distance(tmp.begin(), it) + 1)->find("'") == string::npos)
                            {
                                string assignsig = *(tmp.begin() + distance(tmp.begin(), it) + 1) + (tmp.begin() + distance(tmp.begin(), it) + 2)->substr(0, (tmp.begin() + distance(tmp.begin(), it) + 2)->size() - 1);
                                cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                            }
                            else
                            {
                                assert(*(tmp.begin() + distance(tmp.begin(), it) + 2) == ";");
                                string assignsig = (tmp.begin() + distance(tmp.begin(), it) + 1)->substr((tmp.begin() + distance(tmp.begin(), it) + 1)->find("'") + 2, 1);
                                cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                            }
                        }
                        std::streampos pos = inf.tellg();
                        getline(inf, line);
                        if (line.find("else") != string::npos)
                        {
                            string else_cond;
                            string else_cond_sig;
                            string else_assign_sig;                         
                            line.erase(0, line.find_first_not_of(" "));
                            line.erase(line.find_last_not_of(" ") + 1);
                            vector<std::string> _tmp;
                            _tmp = Split(line, delims);
                            if (_tmp[0] == "else" && _tmp[1] == "if")
                            {
                                cur_dff.type = 3;
                                pair<string, int> cond;
                                if (_tmp[2].find("!") == string::npos)
                                    cond = make_pair(_tmp[2].substr(_tmp[2].find("(") + 1, _tmp[2].find(")") - _tmp[2].find("(") - 1), 1);
                                else
                                    cond = make_pair(_tmp[2].substr(_tmp[2].find("!") + 1, _tmp[2].find(")") - _tmp[2].find("!") - 1), 0);
                                auto it = find(_tmp.begin(), _tmp.end(), "<=");
                                if ((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find(";") != string::npos)
                                {
                                    if ((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find("'") == string::npos)
                                    {
                                        string assignsig = (_tmp.begin() + distance(_tmp.begin(), it) + 1)->substr(0, (_tmp.begin() + distance(_tmp.begin(), it) + 1)->size() - 1);
                                        cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                                    }
                                    else
                                    {
                                        string assignsig = (_tmp.begin() + distance(_tmp.begin(), it) + 1)->substr((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find("'") + 2, 1);
                                        cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                                    }
                                }
                                else if (((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find(";") == string::npos) && ((_tmp.begin() + distance(_tmp.begin(), it) + 2)->find(";") != string::npos))
                                {
                                    if ((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find("'") == string::npos)
                                    {
                                        string assignsig = *(_tmp.begin() + distance(_tmp.begin(), it) + 1) + (_tmp.begin() + distance(_tmp.begin(), it) + 2)->substr(0, (_tmp.begin() + distance(_tmp.begin(), it) + 2)->size() - 1);
                                        cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                                    }
                                    else
                                    {
                                        assert(*(_tmp.begin() + distance(_tmp.begin(), it) + 2) == ";");
                                        string assignsig = (_tmp.begin() + distance(_tmp.begin(), it) + 1)->substr((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find("'") + 2, 1);
                                        cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                                    }
                                }
                            }
                            else
                            {
                                cur_dff.type = 2;
                                pair<string, int> cond(" ", -1);
                                auto it = find(_tmp.begin(), _tmp.end(), "<=");
                                if ((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find(";") != string::npos)
                                {
                                    if ((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find("'") == string::npos)
                                    {
                                        string assignsig = (_tmp.begin() + distance(_tmp.begin(), it) + 1)->substr(0, (_tmp.begin() + distance(_tmp.begin(), it) + 1)->size() - 1);
                                        cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                                    }
                                    else
                                    {
                                        string assignsig = (_tmp.begin() + distance(_tmp.begin(), it) + 1)->substr((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find("'") + 2, 1);
                                        cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                                    }
                                }
                                else if (((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find(";") == string::npos) && ((_tmp.begin() + distance(_tmp.begin(), it) + 2)->find(";") != string::npos))
                                {
                                    if ((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find("'") == string::npos)
                                    {
                                        string assignsig = *(_tmp.begin() + distance(_tmp.begin(), it) + 1) + (_tmp.begin() + distance(_tmp.begin(), it) + 2)->substr(0, (_tmp.begin() + distance(_tmp.begin(), it) + 2)->size() - 1);
                                        cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                                    }
                                    else
                                    {
                                        assert(*(_tmp.begin() + distance(_tmp.begin(), it) + 2) == ";");
                                        string assignsig = (_tmp.begin() + distance(_tmp.begin(), it) + 1)->substr((_tmp.begin() + distance(_tmp.begin(), it) + 1)->find("'") + 2, 1);
                                        cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                                    }
                                }
                            }
                        }
                        else
                            inf.seekg(pos);
                    }
                    else
                    {
                        pair<string, int> cond(" ", -1);
                        if (*(tmp.begin() + mark[0] + 2) == "<=")
                            cur_dff.dff_out = *(tmp.begin() + mark[0] + 1);
                        else if (*(tmp.begin() + mark[0] + 3) == "<=")
                            cur_dff.dff_out = *(tmp.begin() + mark[0] + 1) + *(tmp.begin() + mark[0] + 2);
                        auto it = find(tmp.begin(), tmp.end(), "<=");
                        if ((tmp.begin() + distance(tmp.begin(), it) + 1)->find(";") != string::npos)
                        {
                            if ((tmp.begin() + distance(tmp.begin(), it) + 1)->find("'") == string::npos)
                            {
                                string assignsig = (tmp.begin() + distance(tmp.begin(), it) + 1)->substr(0, (tmp.begin() + distance(tmp.begin(), it) + 1)->size() - 1);
                                cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                            }
                            else
                            {
                                string assignsig = (tmp.begin() + distance(tmp.begin(), it) + 1)->substr((tmp.begin() + distance(tmp.begin(), it) + 1)->find("'") + 2, 1);
                                cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                            }
                        }
                        else if (((tmp.begin() + distance(tmp.begin(), it) + 1)->find(";") != string::npos) && ((tmp.begin() + distance(tmp.begin(), it) + 2)->find(";") == string::npos))
                        {
                            if ((tmp.begin() + distance(tmp.begin(), it) + 1)->find("'") == string::npos)
                            {
                                string assignsig = *(tmp.begin() + distance(tmp.begin(), it) + 1) + (tmp.begin() + distance(tmp.begin(), it) + 2)->substr(0, (tmp.begin() + distance(tmp.begin(), it) + 2)->size() - 1);
                                cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                            }
                            else
                            {
                                assert(*(tmp.begin() + distance(tmp.begin(), it) + 2) == ";");
                                string assignsig = (tmp.begin() + distance(tmp.begin(), it) + 1)->substr((tmp.begin() + distance(tmp.begin(), it) + 1)->find("'") + 2, 1);
                                cur_dff.assignsig_condsig.push_back(make_pair(assignsig, cond));
                            }
                        }
                    }
                    dff_outs.push_back(cur_dff.dff_out);                   
                    vector<string> cur_dff_in_ports;
                    for (auto i = cur_dff.assignsig_condsig.begin(); i != cur_dff.assignsig_condsig.end(); i++)
                    {
                        if ((i->first) != "0" && (i->first) != "1")
                        {
                            auto find_pinbit = pin_bits.find(i->first);
                            assert(find_pinbit != pin_bits.end());
                            cur_dff_in_ports.push_back(i->first);
                        }
                        if (i->second.first != " ")
                        {
                            auto find_pinbit = pin_bits.find(i->second.first);
                            assert(find_pinbit != pin_bits.end());
                            cur_dff_in_ports.push_back(i->second.first);
                        }
                    }
                    cur_dff.dff_in_ports = cur_dff_in_ports;
                    dffs[cur_dff.num] = cur_dff;
                    net_from_id_dff[cur_dff.dff_out] = cur_dff.num;
                    for (int i = 0; i < cur_dff_in_ports.size(); i++)
                    {
                        net_for_id_dff[cur_dff_in_ports[i]].push_back(cur_dff.num);
                    }
                }

                // alu instance parsing
                else 
                {               
                    continue;
                }
            }
        }
    }

    for (map<string, Pin>::iterator i = pins.begin(); i != pins.end(); i++) 
    {
        if (i->second.type == "input") {
            input_num += 1;
            input_bits += i->second.size;
        }
        else if (i->second.type == "output") {
            output_num += 1;
            output_bits += i->second.size;
        }
        else if (i->second.type == "wire") {
            inter_num += 1;
            inter_bits += i->second.size;
        }
    }

    std::cout << endl;
    std::cout << "=== " << top_module_name << " ===" << endl;
    std::cout << endl;
    std::cout.setf(ios::left);
    std::cout.width(20);
    std::cout << "input signals: ";
    std::cout.unsetf(ios::left);
    std::cout.width(20);
    std::cout << input_num << endl;
    std::cout.setf(ios::left);
    std::cout.width(20);
    std::cout << "input bits: ";
    std::cout.unsetf(ios::left);
    std::cout.width(20);
    std::cout << input_bits << endl;
    std::cout.setf(ios::left);
    std::cout.width(20);
    std::cout << "output signals: ";
    std::cout.unsetf(ios::left);
    std::cout.width(20);
    std::cout << output_num << endl;
    std::cout.setf(ios::left);
    std::cout.width(20);
    std::cout << "output bits: ";
    std::cout.unsetf(ios::left);
    std::cout.width(20);
    std::cout << output_bits << endl;
    std::cout.setf(ios::left);
    std::cout.width(20);
    std::cout << "internal signals: ";
    std::cout.unsetf(ios::left);
    std::cout.width(20);
    std::cout << inter_num << endl;
    std::cout.setf(ios::left);
    std::cout.width(20);
    std::cout << "inter bits: ";
    std::cout.unsetf(ios::left);
    std::cout.width(20);
    std::cout << inter_bits << endl;
    std::cout.setf(ios::left);
    std::cout.width(20);
    std::cout << "$lut cells: ";
    std::cout.unsetf(ios::left);
    std::cout.width(20);
    std::cout << lut_num << endl;
    std::cout.setf(ios::left);
    std::cout.width(20);
    std::cout << "$dff cells: ";
    std::cout.unsetf(ios::left);
    std::cout.width(20);
    std::cout << dff_num << endl;
    std::cout << endl;

    inf.close();
}

vector<std::string> Parser::Split(const std::string &str, const std::string &delim) {
    vector<std::string> res;
    if(str == ""){
        return res;
    }
    char *strs = new char[str.length() + 1];
    strcpy(strs, str.c_str());
    char *delims = new char[delim.length() + 1];
    strcpy(delims, delim.c_str());

    char *p = strtok(strs, delims);
    while(p) {
        std::string s = p;
        res.push_back(s);
        p = strtok(NULL, delims);
    }
    return res;
}

string Parser::HextoBinary_x(string HexDigit)
{
    string BinDigit;
    for (int i = 0; i < HexDigit.length(); i++)
    {
        char e = HexDigit[i];
        if (e >= 'a' && e <= 'f')
        {
            int a = static_cast<int>(e - 'a' + 10);
            switch (a)
            {
            case 10:
                BinDigit += "1010";
                break;
            case 11:
                BinDigit += "1011";
                break;
            case 12:
                BinDigit += "1100";
                break;
            case 13:
                BinDigit += "1101";
                break;
            case 14:
                BinDigit += "1110";
                break;
            case 15:
                BinDigit += "1111";
                break;
            }
        }
        else if (isdigit(e))
        {
            int b = static_cast<int>(e - '0');
            switch (b)
            {
            case 0:
                BinDigit += "0000";
                break;
            case 1:
                BinDigit += "0001";
                break;
            case 2:
                BinDigit += "0010";
                break;
            case 3:
                BinDigit += "0011";
                break;
            case 4:
                BinDigit += "0100";
                break;
            case 5:
                BinDigit += "0101";
                break;
            case 6:
                BinDigit += "0110";
                break;
            case 7:
                BinDigit += "0111";
                break;
            case 8:
                BinDigit += "1000";
                break;
            case 9:
                BinDigit += "1001";
                break;
            }
        }
        else if (e == 'x')
        {
            BinDigit += "xxxx";
        }
    }
    return BinDigit;
}